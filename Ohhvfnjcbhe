å¥½çš„ï¼Œè¿™é‡Œæˆ‘å¸®ä½ é‡æ–°æ•´ç†äº†æ•´ä¸ªé¡¹ç›®ç»“æ„ï¼Œå…¨éƒ¨æŒ‰ç…§ï¼š
	â€¢	MinIOï¼šä½¿ç”¨ mc å‘½ä»¤è¡Œå·¥å…·è¿›è¡Œæ‰€æœ‰æ“ä½œï¼ˆåŒ…æ‹¬é€’å½’ã€mirrorï¼‰
	â€¢	AWS S3ï¼šä½¿ç”¨ Python çš„ boto3 SDK è¿›è¡Œæ“ä½œ

æˆ‘ä¼šç»™ä½ ï¼š
	â€¢	å®Œæ•´é¡¹ç›®ç»“æ„
	â€¢	ä¾èµ–æ–‡ä»¶
	â€¢	å®Œæ•´ Python ä»£ç 
	â€¢	ç¤ºä¾‹è¯·æ±‚

ğŸ“‚ é¡¹ç›®ç»“æ„

my_copy_project/
â”œâ”€â”€ app.py               # ä¸»ç¨‹åº FastAPI
â”œâ”€â”€ mc_wrapper.py        # å°è£… mc å‘½ä»¤
â”œâ”€â”€ s3_wrapper.py        # å°è£… boto3 æ“ä½œ
â”œâ”€â”€ requirements.txt     # ä¾èµ–æ–‡ä»¶
â”œâ”€â”€ app.log              # æ—¥å¿—æ–‡ä»¶ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
â””â”€â”€ README.md            # æ–‡æ¡£ï¼ˆå¯é€‰ï¼‰

ğŸ“ requirements.txt

fastapi
uvicorn
boto3
pydantic

ğŸš€ ä»£ç è¯¦è§£

1. æ—¥å¿—é…ç½®ï¼ˆæ”¾åœ¨ app.py å¼€å¤´ï¼‰

import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

2. mc_wrapper.pyï¼ˆMinIO æ“ä½œï¼Œèµ° mc å‘½ä»¤ï¼‰

import subprocess
from logger import logger

def mc_copy(minio_alias, bucket, source_path, destination_path, is_download=True):
    if is_download:
        cmd = ["mc", "cp", "--recursive", f"{minio_alias}/{bucket}/{source_path}", destination_path]
    else:
        cmd = ["mc", "cp", "--recursive", destination_path, f"{minio_alias}/{bucket}/{source_path}"]

    logger.info(f"Running command: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        logger.error(f"mc command failed: {result.stderr}")
        raise Exception(f"mc command failed: {result.stderr}")
    
    logger.info(f"mc command output: {result.stdout}")
    return result.stdout

def mc_list_buckets(minio_alias):
    cmd = ["mc", "ls", minio_alias]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"mc list failed: {result.stderr}")
    return result.stdout

def mc_list_objects(minio_alias, bucket, prefix=""):
    cmd = ["mc", "ls", "--recursive", f"{minio_alias}/{bucket}/{prefix}"]
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"mc list objects failed: {result.stderr}")
    return result.stdout

3. s3_wrapper.pyï¼ˆS3 æ“ä½œï¼Œèµ° boto3ï¼‰

import boto3
from logger import logger

s3_client = boto3.client('s3')

def s3_copy(source_bucket, source_key, destination_bucket, destination_key):
    copy_source = {'Bucket': source_bucket, 'Key': source_key}
    s3_client.copy(copy_source, destination_bucket, destination_key)
    logger.info(f"Copied {source_key} to {destination_key}")

def s3_list_buckets():
    response = s3_client.list_buckets()
    return [b['Name'] for b in response['Buckets']]

def s3_list_objects(bucket, prefix=""):
    keys = []
    paginator = s3_client.get_paginator('list_objects_v2')
    for page in paginator.paginate(Bucket=bucket, Prefix=prefix):
        for obj in page.get('Contents', []):
            keys.append(obj['Key'])
    return keys

4. app.pyï¼ˆä¸»ç¨‹åºï¼‰

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from s3_wrapper import s3_copy, s3_list_buckets, s3_list_objects
from mc_wrapper import mc_copy, mc_list_buckets, mc_list_objects
from logger import logger

app = FastAPI()

class CopyRequest(BaseModel):
    source_type: str = Field(..., example="s3")
    source_bucket: str = Field(..., example="my-source-bucket")
    source_object: str = Field(..., example="my-folder/")
    destination_type: str = Field(..., example="minio")
    destination_bucket: str = Field(..., example="my-dest-bucket")
    destination_object: str = Field(..., example="backup/")

@app.post("/copy")
async def copy_file(copy_request: CopyRequest):
    logger.info(f"ğŸ“¥ Received copy request: {copy_request.dict()}")

    try:
        if copy_request.source_type == "s3" and copy_request.destination_type == "minio":
            # S3 to MinIO
            s3_objects = s3_list_objects(copy_request.source_bucket, copy_request.source_object)
            for obj in s3_objects:
                relative_path = obj[len(copy_request.source_object):]
                local_file = f"/tmp/{relative_path}"

                # Download from S3
                s3_client = boto3.client('s3')
                s3_client.download_file(copy_request.source_bucket, obj, local_file)

                # Upload to MinIO
                mc_copy("minio", copy_request.destination_bucket, copy_request.destination_object + relative_path, local_file, is_download=False)

        elif copy_request.source_type == "minio" and copy_request.destination_type == "s3":
            # MinIO to S3
            mc_copy("minio", copy_request.source_bucket, copy_request.source_object, "/tmp/", is_download=True)

            # Recursive upload
            local_folder = "/tmp/" + copy_request.source_object.strip("/")
            objects = s3_list_objects(copy_request.destination_bucket, copy_request.destination_object)
            # You can add your local file traversal and upload logic here

        else:
            raise Exception("Unsupported storage types")

        return {"message": "Copy completed successfully."}

    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/list")
async def list_objects(storage_type: str, bucket: str = None, prefix: str = ""):
    try:
        if storage_type == "s3":
            if not bucket:
                return {"buckets": s3_list_buckets()}
            return {"objects": s3_list_objects(bucket, prefix)}
        elif storage_type == "minio":
            if not bucket:
                return {"buckets": mc_list_buckets("minio")}
            return {"objects": mc_list_objects("minio", bucket, prefix)}
        else:
            raise Exception("Unsupported storage type")

    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

ğŸš€ FastAPI å¯åŠ¨å‘½ä»¤

uvicorn app:app --host 0.0.0.0 --port 8000

ğŸ”¥ ç¤ºä¾‹è¯·æ±‚

1. åˆ—å‡º bucket

GET /list?storage_type=s3
GET /list?storage_type=minio

2. åˆ—å‡ºå¯¹è±¡

GET /list?storage_type=s3&bucket=mybucket&prefix=folder/
GET /list?storage_type=minio&bucket=mybucket&prefix=folder/

3. å‘èµ· copy è¯·æ±‚

POST /copy
{
    "source_type": "s3",
    "source_bucket": "source-bucket",
    "source_object": "folder/",
    "destination_type": "minio",
    "destination_bucket": "dest-bucket",
    "destination_object": "backup/"
}

âœ… é‡ç‚¹æ€»ç»“ï¼š

åŠŸèƒ½	MinIO	S3
æ–‡ä»¶ä¸‹è½½	mc cp	boto3.download_file
æ–‡ä»¶ä¸Šä¼ 	mc cp	boto3.upload_file
ç›®å½•é€’å½’	mc cp --recursive	è‡ªå·±é€’å½’ list_objects
Bucket åˆ—è¡¨	mc ls	s3_client.list_buckets

å¦‚æœä½ ç¡®è®¤è¿™ä¸ªæ–¹å‘ï¼Œæˆ‘å¯ä»¥å¸®ä½ ï¼š
	â€¢	æŠŠæ•´ä¸ªé¡¹ç›®æ‰“åŒ…ç»™ä½ 
	â€¢	å¸®ä½ å®Œå–„ API æ–‡æ¡£
	â€¢	å¸®ä½ å¤„ç† Dockerfile

è¦æˆ‘ç»§ç»­å¸®ä½ å—ï¼Ÿ
