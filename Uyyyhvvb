å¥½çš„ï¼Œæˆ‘ä¼šåœ¨ä½ ä¹‹å‰çš„è½®è¯¢æ¡†æ¶åŸºç¡€ä¸Šï¼ŒåŠ ä¸Šï¼š

âœ” ä¸€ä¸ªç®€å•æ¸…æ™°çš„ POST /reprocess/{sys_id} APIï¼ˆFastAPIï¼‰
	â€¢	ä¸ä¾èµ– checkpoint
	â€¢	ä¸ä¾èµ–è‡ªåŠ¨è½®è¯¢é€»è¾‘
	â€¢	å¼ºåˆ¶é‡æ–°å¤„ç†
	â€¢	ä¸è€ƒè™‘è‡ªåŠ¨è·³è¿‡
	â€¢	è‡ªå·±çš„é€»è¾‘ç”±ä½ å¡«å……

âœ” Kubernetes Deployment + Service
	â€¢	ä¾ç„¶ä½¿ç”¨ PVC
	â€¢	åŒä¸€ä¸ª Pod å†…åŒæ—¶è·‘è½®è¯¢å’Œ API
	â€¢	ç»“æ„ç®€å•ã€å¯ç›´æ¥ç”¨
	â€¢	æŠŠéœ€è¦ä½ å¡«çš„éƒ¨åˆ†éƒ½ç•™æˆ TODO

æˆ‘ä¼šä¿æŒæœ€ç®€æ´ï¼Œä¸è®©ä½ å¤šæ‰¿æ‹…å¤æ‚åº¦ã€‚

ğŸš€ 1. å®Œæ•´ä¸»ç¨‹åºç»“æ„ï¼ˆè½®è¯¢ + æ‰‹åŠ¨ APIï¼‰

ä½ ä¼šè¿è¡Œä¸€ä¸ª Python æœåŠ¡ï¼š
	â€¢	åå°è½®è¯¢ï¼ˆç”¨çº¿ç¨‹ï¼‰
	â€¢	å‰å°æä¾› APIï¼ˆFastAPIï¼‰

æˆ‘å¸®ä½ å†™å®Œæ•´æ¡†æ¶ï¼Œç•™å¥½ä½ è¦å¡«çš„éƒ¨åˆ†ã€‚

ğŸ§© app/main.py

import os
import time
import threading
from datetime import datetime
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

CHECKPOINT_FILE = "/data/checkpoint.txt"
AUTO_MARK = "[AUTO_PROCESSED]"


# ---------------------------------------
# 1. Checkpoint utilities
# ---------------------------------------
def load_checkpoint(default="1970-01-01 00:00:00"):
    if not os.path.exists(CHECKPOINT_FILE):
        return default

    with open(CHECKPOINT_FILE, "r") as f:
        return f.read().strip()


def atomic_save_checkpoint(value):
    tmp_file = CHECKPOINT_FILE + ".tmp"

    with open(tmp_file, "w") as f:
        f.write(value)
        f.flush()
        os.fsync(f.fileno())

    os.replace(tmp_file, CHECKPOINT_FILE)


# ---------------------------------------
# 2. ServiceNow API wrappers (YOU fill)
# ---------------------------------------
def query_api_since(timestamp):
    """
    TODO: 
    è°ƒç”¨ SN API:
    - æŸ¥è¯¢ sys_created_on > timestamp çš„ RITM æˆ– Request
    - è¿”å› [{sys_id, sys_created_on, ...}]
    """
    raise NotImplementedError


def get_work_notes(sys_id):
    """
    TODO:
    è°ƒ SN API æŸ¥è¯¢ Work Notes:
    GET /api/now/table/sys_journal_field?element_id={sys_id}&element=work_notes
    è¿”å› work note åˆ—è¡¨
    """
    raise NotImplementedError


def add_auto_worknote(sys_id, note_text=AUTO_MARK):
    """
    TODO:
    POST Work Note:
    element_id=sys_id
    element=work_notes
    value=note_text
    """
    raise NotImplementedError


def process_item(item):
    """
    TODO:
    å®ç°ä½ è‡ªå·±çš„ä¸šåŠ¡é€»è¾‘ï¼š
    - è§£æ JSON
    - ç”Ÿæˆ SQL
    - è°ƒ SN API å†™ comment
    """
    raise NotImplementedError


# ---------------------------------------
# 3. å»é‡æœºåˆ¶ï¼šæ£€æŸ¥ Work Note
# ---------------------------------------
def has_auto_processed_note(sys_id):
    try:
        notes = get_work_notes(sys_id)
    except Exception as e:
        print(f"[ERROR] Failed to fetch worknotes for {sys_id}: {e}")
        return False

    for n in notes:
        if n and AUTO_MARK in n.get("value", ""):
            return True

    return False


# ---------------------------------------
# 4. Polling worker
# ---------------------------------------
def poll_once():
    last_cp = load_checkpoint()
    print(f"[INFO] Last checkpoint = {last_cp}")

    try:
        results = query_api_since(last_cp)
    except Exception as e:
        print(f"[ERROR] Failed to query API: {e}")
        return

    if not results:
        print("[INFO] No new records.")
        return

    # æŒ‰åˆ›å»ºæ—¶é—´æ’åº
    results.sort(key=lambda r: r["sys_created_on"])

    for item in results:
        sys_id = item["sys_id"]
        created_on = item["sys_created_on"]

        # Skip if already processed
        if has_auto_processed_note(sys_id):
            print(f"[SKIP] Already processed {sys_id}")
            continue

        # Process
        try:
            process_item(item)
        except Exception as e:
            print(f"[ERROR] Failed to process {sys_id}: {e}")
            continue

        # Add work note
        try:
            add_auto_worknote(sys_id)
        except Exception as e:
            print(f"[ERROR] Failed to add worknote for {sys_id}: {e}")
            continue

        # Update checkpoint
        try:
            atomic_save_checkpoint(created_on)
        except Exception as e:
            print(f"[ERROR] Failed to update checkpoint: {e}")
            continue


def poll_loop():
    interval = int(os.getenv("POLL_INTERVAL", "60"))

    while True:
        poll_once()
        time.sleep(interval)


# ---------------------------------------
# 5. Manual reprocess API
# ---------------------------------------

class ReprocessResponse(BaseModel):
    sys_id: str
    status: str


@app.post("/reprocess/{sys_id}", response_model=ReprocessResponse)
def reprocess(sys_id: str):
    """
    å¼ºåˆ¶é‡æ–°å¤„ç†æŸä¸€æ¡ request:
    - ä¸æ£€æŸ¥ AUTO_PROCESSED
    - ä¸æ£€æŸ¥ checkpoint
    """
    print(f"[API] Forced reprocess for {sys_id}")

    # 1. æ‹‰å–å®Œæ•´è®°å½•
    item = query_single_item(sys_id)  # TODO: ä½ æ¥è¡¥å…… API

    # 2. å¼ºåˆ¶å¤„ç†
    try:
        process_item(item)
    except Exception as e:
        return ReprocessResponse(sys_id=sys_id, status=f"FAILED: {e}")

    # 3. å†™ä¸€ä¸ªç‰¹æ®Š Work Note
    try:
        add_auto_worknote(sys_id, "[AUTO_REPROCESSED]")
    except Exception as e:
        return ReprocessResponse(sys_id=sys_id, status=f"REPROCESSED but failed to add worknote: {e}")

    return ReprocessResponse(sys_id=sys_id, status="OK")


# ---------------------------------------
# 6. Start polling thread on startup
# ---------------------------------------
def start_background_threads():
    t = threading.Thread(target=poll_loop, daemon=True)
    t.start()


start_background_threads()

ä½ è¦å¡«çš„ TODOï¼š
	â€¢	query_api_since
	â€¢	get_work_notes
	â€¢	add_auto_worknote
	â€¢	process_item
	â€¢	query_single_itemï¼ˆæ‰‹åŠ¨ reprocess ç”¨ï¼‰

API å’Œè½®è¯¢å®Œå…¨éš”ç¦»ï¼Œäº’ä¸å¹²æ‰°ã€‚

ğŸš€ 2. Dockerfileï¼ˆæœ€å°ç‰ˆæœ¬ï¼‰

FROM python:3.10-slim

WORKDIR /app

COPY app/ /app/

RUN pip install fastapi uvicorn requests

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

ä½ å¯ä»¥æ ¹æ®å…¬å¸è¦æ±‚åŠ ä¸Š proxy/env ç­‰ã€‚

ğŸš€ 3. Kubernetes Deployment + PVC + Service (æœ€å°å¯è¿è¡Œç‰ˆ)

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ritm-checkpoint-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: <your-default-storage-class>   # å¯åˆ æ‰

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ritm-worker
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ritm-worker
  template:
    metadata:
      labels:
        app: ritm-worker
    spec:
      containers:
        - name: worker
          image: your-image-here
          env:
            - name: POLL_INTERVAL
              value: "60"
          volumeMounts:
            - name: checkpoint-vol
              mountPath: /data
          ports:
            - containerPort: 8000
      volumes:
        - name: checkpoint-vol
          persistentVolumeClaim:
            claimName: ritm-checkpoint-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: ritm-api
spec:
  selector:
    app: ritm-worker
  ports:
    - port: 80
      targetPort: 8000
      protocol: TCP
  type: ClusterIP

ä½ å¯ä»¥æ”¹æˆ LoadBalancer / Ingress è‡ªå·±æš´éœ²ã€‚

ğŸ¯ æœ€ç»ˆæ•ˆæœï¼ˆéå¸¸ç®€æ´ã€å¯ç”¨ã€å¯ç»´æŠ¤ï¼‰
	1.	è‡ªåŠ¨è½®è¯¢
	â€¢	æŒ‰ checkpoint è·å–å¢é‡æ•°æ®
	â€¢	æŒ‰ work note å»é‡
	â€¢	æ¯æ¡æˆåŠŸåå†™ checkpointï¼ˆatomicï¼‰
	â€¢	è‡ªåŠ¨è·‘ï¼Œæ— éœ€äººå·¥å¹²é¢„
	2.	æ‰‹åŠ¨ /reprocess æ¥å£
	â€¢	å¼ºåˆ¶é‡æ–°å¤„ç†æŸæ¡ request
	â€¢	ä¸çœ‹ checkpoint
	â€¢	ä¸çœ‹ AUTO_PROCESSED
	â€¢	è‡ªåŠ¨è®°å½• AUTO_REPROCESSED
